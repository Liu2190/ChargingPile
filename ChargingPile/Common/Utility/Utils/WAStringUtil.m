/*! @class @abstract 字符串操作类 */#import "WAStringUtil.h"#include <sys/socket.h>#include <sys/sysctl.h>#include <net/if.h>#include <net/if_dl.h>#import <CommonCrypto/CommonDigest.h>#import <QuartzCore/QuartzCore.h>#import "sys/utsname.h"@implementation CWAStringUtil//新建字符串+ (NSString *)getWAString:(NSString*)aString {  NSString *str = nil;  if (!aString)   {     str = nil;  }  else  {     str = [NSString stringWithString:aString];  }  return str;}//比较两个c字符串+ (BOOL)compareCString:(char*)aCstr1 Cstr2:(char*)aCstr2{  if(strcmp(aCstr1, aCstr2) == 0)  {    return YES;  }  else   {    return NO;  }}//判断两者内容是否相同+ (BOOL)compareStringIfOrderedSame:(NSString *)aStr1 Str2:(NSString *)aStr2{  BOOL result = [aStr1 compare:aStr2] == NSOrderedSame;  return result;}//判断两对象值的大小(按字母顺序进行比较，astring02大于astring01为真)+ (BOOL)compareStringIfOrderedAscending:(NSString *)aStr1 Str2:(NSString *)aStr2{  BOOL result = [aStr1 compare:aStr2] == NSOrderedAscending;  return result;}//不考虑大 小写比较字符串 判断两对象值的大小(按字母顺序进行比较，astring02小于astring01为真+ (BOOL)compareStringIfOrderedSameCaseInsensitive:(NSString *)aStr1 Str2:(NSString *)aStr2{    BOOL result = [aStr1 caseInsensitiveCompare:aStr2] == NSOrderedSame;  return result;}//改变字符串的大小写//大写+ (NSString*)uppercaseWAString:(NSString *)aStr{   NSString *str = nil;  if (!aStr)   {    str = nil;  }  else  {    str = [aStr uppercaseString];  }  return str;}//小写+ (NSString*)lowercaseWAString:(NSString *)aStr{  NSString *str = nil;  if (!aStr)   {    str =  nil;  }  else  {    str = [aStr lowercaseString];  }  return str;}//首字母大小+ (NSString*)capitalizedWAString:(NSString *)aStr{  NSString *str = nil;  if (!aStr)   {    str =  nil;  }  else  {    str = [aStr capitalizedString];  }  return str;}//截取到index + (NSString*)getStringToIndex:(NSInteger)aIndex fromString:(NSString *)aFromString{  NSString *str = nil;  if (!aFromString && aIndex < 0)   {    str =  nil;  }  else  {    str = [aFromString substringToIndex:aIndex];  }  return str;}//从index开始截取+ (NSString*)getStringFromIndex:(NSInteger)aIndex fromString:(NSString *)aFromString{  NSString *str = nil;  if (!aFromString && aIndex < 0)   {    str =  nil;  }  else  {    str = [aFromString substringFromIndex:aIndex];  }   return str;}//从index1截取到index2+ (NSString*)getStringFromIndex:(NSInteger)aIndex1 Index2:(NSInteger)aIndex2                                                fromString:(NSString *)aFromString{   NSString *str = nil;  if ((!aFromString)||(aIndex1 <= 0)||(aIndex2 <= 0))   {    str = nil;  }  else  {   str = [aFromString substringWithRange:NSMakeRange(aIndex1, aIndex2)];  }  return str;}#pragma mark 字符串长度处理  字符串长度超过15截取+ (NSString *)calculateStringAndCutoutString :(NSString *)aTextString{    // 这个方法是截取8个字   NSString *resultStr = nil;    if(aTextString && [aTextString length] > 15 )  {    NSString *stringLengthOf16 = [CWAStringUtil calculateStringAndCutoutString:aTextString withMaxLen:15];    resultStr = [NSString stringWithFormat:@"%@  %@",stringLengthOf16,@"..."];  }  return resultStr;}#pragma mark 根据长度截取字符串+ (NSUInteger)calculateStringLength :(NSString *)aTextString{   // 0x20 0x7E   float textStringLength = 0;  for (int i = 0; i < [aTextString length]; i++)  {    float stringLength = 0;    int a = [aTextString characterAtIndex:i];    if (a == 8198)     {      stringLength = 0;    }    else if (a >= 0x20 && a <= 0x7E)    {      stringLength = 0.5;    }    else    {      stringLength = 1.0;    }    textStringLength += stringLength;  }  return ceilf(textStringLength);}+ (NSString *)calculateStringAndCutoutString :(NSString *)aTextString                                    withMaxLen:(NSInteger)aMaxLength{      float textStringLength = 0;    NSString *retString = aTextString;     for (int i = 0; i < [aTextString length]; i++)    {        float stringLength = 0;        int a = [aTextString characterAtIndex:i];        if (a >= 0x20 && a <= 0x7E)            stringLength = 0.5;        else            stringLength = 1.0;        textStringLength += stringLength;        if (textStringLength > aMaxLength)        {            retString = [aTextString substringWithRange:NSMakeRange(0, i)];            break;        }    }    return retString;}+ (NSString*)insertString:(NSInteger)aIndex  digString:(NSString *)aDigstring                                             fromString:(NSString *)aFromString;{   if ((!aDigstring)||(!aFromString)||(aIndex < 0))   {    return nil;  }    NSString *retString = aFromString;   [[NSMutableString stringWithString:retString] insertString:aDigstring atIndex:aIndex];  return [NSString stringWithString:retString];}#pragma mark MD5用于字符串+ (NSString *)md5ToString:(NSString *)aFromString{  const char *cStr = [aFromString UTF8String];  unsigned char result[16];  CC_MD5( cStr, (int)strlen(cStr), result );  return [NSString stringWithFormat:          @"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",          result[0], result[1], result[2], result[3],           result[4], result[5], result[6], result[7],          result[8], result[9], result[10], result[11],          result[12], result[13], result[14], result[15]]; }+ (NSString *)md5ToData:(NSData *)aData{  const char *cStr = [aData bytes];  unsigned char result[16];  CC_MD5( cStr, (int)[aData length], result );  return [NSString stringWithFormat:          @"%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X%02X",          result[0], result[1], result[2], result[3],           result[4], result[5], result[6], result[7],          result[8], result[9], result[10], result[11],          result[12], result[13], result[14], result[15]]; }+ (NSString *)dateToString:(NSData *)aData{  return [[[NSString alloc] initWithData:aData encoding:NSUTF8StringEncoding] autorelease];}+ (NSData *)stringToData:(NSString *)aFromString{   if (!aFromString)   {    return nil;  }  return [aFromString dataUsingEncoding: NSUTF8StringEncoding];}+ (Byte *)dataToByte:(NSData *)aData{   return (Byte *)[aData bytes];}+(NSString *)EncodeUTF8Str:(NSString *)aEnCodeStr{   NSString *newStr = nil;  if (!aEnCodeStr)   {      newStr = nil;  }  else  {  CFStringRef nonAlphaNumValidChars = CFSTR("![DISCUZ_CODE_1]’()*+,-./:;=?@_~");            NSString *preprocessedString = (NSString *)CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault, (CFStringRef)aEnCodeStr, CFSTR(""), kCFStringEncodingUTF8);       newStr = [(NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,(CFStringRef)preprocessedString,NULL,nonAlphaNumValidChars,kCFStringEncodingUTF8) autorelease];        [preprocessedString release];   }  return newStr; }+ (NSString *) EncodeGB2312Str:(NSString *) aEnCodeStr{    NSString *newStr = nil;  if (!aEnCodeStr)   {    newStr =  nil;  }  else  {    CFStringRef nonAlphaNumValidChars = CFSTR("![DISCUZ_CODE_1]’()*+,-./:;=?@_~");              NSString *preprocessedString = (NSString *) CFURLCreateStringByReplacingPercentEscapesUsingEncoding(kCFAllocatorDefault,  (CFStringRef)aEnCodeStr, CFSTR(""), kCFStringEncodingGB_18030_2000);         newStr = [(NSString *)CFURLCreateStringByAddingPercentEscapes(kCFAllocatorDefault,(CFStringRef)preprocessedString,NULL,nonAlphaNumValidChars,kCFStringEncodingGB_18030_2000) autorelease];          [preprocessedString release];    }    return newStr;          } // 将16进制数据转化成Byte 数组+ (Byte *)string16ToByte:(NSString *)aFromString{  NSData *newData;  if (!aFromString)   {    newData = nil;  }  else  {    NSString *hexString = aFromString; //16进制字符串    int j=0;    Byte bytes[128];  ///3ds key的Byte 数组， 128位    for(int i=0;i<[hexString length];i++)    {      int int_ch;  /// 两位16进制数转化后的10进制数          unichar hex_char1 = [hexString characterAtIndex:i]; ////两位16进制数中的第一位(高位*16)      int int_ch1;      if(hex_char1 >= '0' && hex_char1 <='9')      {        int_ch1 = (hex_char1-48)*16;   //// 0 的Ascll - 48      }      else if(hex_char1 >= 'A' && hex_char1 <='F')      {        int_ch1 = (hex_char1-55)*16; //// A 的Ascll - 65      }      else      {        int_ch1 = (hex_char1-87)*16; //// a 的Ascll - 97      }         i++;      unichar hex_char2 = [hexString characterAtIndex:i]; ///两位16进制数中的第二位(低位)      int int_ch2;      if(hex_char2 >= '0' && hex_char2 <='9')      {        int_ch2 = (hex_char2-48); //// 0 的Ascll - 48      }      else if(hex_char1 >= 'A' && hex_char1 <='F')      {        int_ch2 = hex_char2-55; //// A 的Ascll - 65      }      else      {        int_ch2 = hex_char2-87; //// a 的Ascll - 97      }             int_ch = int_ch1+int_ch2;      //NSLog(@"int_ch=%d",int_ch);      bytes[j] = int_ch;  ///将转化后的数放入Byte数组里      j++;    }    newData = [[[NSData alloc] initWithBytes:bytes length:128]autorelease];  }  return (Byte *) newData;}/////数组+ (NSMutableArray *) removeObjectAtIndex:(unsigned)aIndex fromString:(NSMutableArray *)aFromString; {  NSMutableArray *array = [NSMutableArray arrayWithObjects:aFromString,nil];  [array removeObjectAtIndex:aIndex];    return  array;}//校验url+ (BOOL) validateURL:(NSString *)aURl{  NSRegularExpression *regularexpression = [[NSRegularExpression alloc] initWithPattern:@"\\b[a-zA-Z0-9\\-.]+(?::(\\d+))?(?:(?:/[a-zA-Z0-9\\-._?,'+\\&%$=~*!():@\\\\]*)+)?"                                                                                options:NSRegularExpressionCaseInsensitive                                                                                  error:nil];  NSUInteger numberofMatch = [regularexpression numberOfMatchesInString:aURl                                                                options:NSMatchingReportProgress                                                                  range:NSMakeRange(0, aURl.length)];  [regularexpression release];  if(numberofMatch > 0)  {    return YES;  }  return NO;}#pragma mark 获取字符串字体在界面上显示的长度+ (CGFloat) getWidthOfString:(NSString *)aString withFont:(UIFont *)aFont{    CGRect detailSize = [aString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:aFont}  context:nil];    return detailSize.size.width;}+ (NSString *)getSubStringOfString:(NSString *)aString                            withFont:(UIFont *)aFont                         withWidth:(CGFloat)aWidth{    CGRect detailSize = [aString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:aFont}  context:nil];  CGSize aStringSize = detailSize.size;  int i = 0 ;  NSString *subString = aString;   while(aStringSize.width > aWidth)  {    i++;    subString = [aString substringToIndex:([aString length] - i)];      CGRect detailSize1 = [subString boundingRectWithSize:CGSizeMake(MAXFLOAT, 30) options:NSStringDrawingUsesLineFragmentOrigin attributes:@{NSFontAttributeName:aFont}  context:nil];    aStringSize = detailSize1.size;  }  return subString;}/*** 判断是否为数字，如果含有非数字字符返回nil **/+(NSMutableString *)filteNumber:(NSString *) number{  NSMutableString *strippedString = [NSMutableString                                      stringWithCapacity:number.length];    NSScanner *scanner = [NSScanner scannerWithString:number];  NSCharacterSet *numbers = [NSCharacterSet                              characterSetWithCharactersInString:@"0123456789"];  //循环验证是否为数字  while ([scanner isAtEnd] == NO)   {    NSString *buffer;    if ([scanner scanCharactersFromSet:numbers intoString:&buffer])     {      [strippedString appendString:buffer];    }    // --------- Add the following to get out of endless loop    else     {      return nil;      //            [scanner setScanLocation:([scanner scanLocation] + 1)];    }        // --------- End of addition  }  return strippedString;}//根据给定的分隔符分隔给定的字符串+(NSMutableArray*)divideString:(NSString*)aString                  WithSeparator:(NSString*)aSeparator{    NSMutableArray * divideArray = nil;    if (![aString isKindOfClass:[NSString class]]        ||![aSeparator isKindOfClass:[NSString class]])     {        //传入的参数类型不对        divideArray = nil;    }    else     {        divideArray = [[[NSMutableArray alloc] init] autorelease];        //待查找字符串        NSString * srcStr = aString;        while (YES)        {            //查找分隔符的位置            NSRange range = [srcStr rangeOfString:aSeparator];            if (range.length >0)            {                //找到了                NSString * aDivideStr = [srcStr substringToIndex:range.location];                [divideArray addObject:aDivideStr];                srcStr = [srcStr substringFromIndex:range.location + range.length];            }            else             {                //没有找到                NSString * aDivideStr = srcStr;                [divideArray addObject:aDivideStr];                //退出循环                break;            }        }    }    return divideArray;}@end